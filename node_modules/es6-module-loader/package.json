{
  "name": "es6-module-loader",
  "description": "An ES6 Module Loader shim",
  "version": "0.4.1",
  "homepage": "https://github.com/ModuleLoader/es6-module-loader",
  "author": {
    "name": "Guy Bedford, Luke Hoban, Addy Osmani",
    "email": "addyosmani@gmail.com",
    "url": "https://github.com/ModuleLoader"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/ModuleLoader/es6-module-loader"
  },
  "bugs": {
    "url": "https://github.com/ModuleLoader/es6-module-loader/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/ModuleLoader/es6-module-loader/blob/master/LICENSE-MIT"
    }
  ],
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-uglify": "~0.2.2",
    "grunt-contrib-jshint": "~0.6.0"
  },
  "keywords": [
    "script",
    "loader",
    "es6",
    "harmony"
  ],
  "engines": {
    "node": ">=0.8.0"
  },
  "main": "lib/es6-module-loader",
  "scripts": {
    "test": "grunt test"
  },
  "files": [
    "lib/es6-module-loader.js"
  ],
  "dependencies": {
    "traceur": "0.0.8"
  },
  "readme": "# ES6 Module Loader Polyfill\n\n_Fully up to date with the latest specification_\n\nThe new ES6 module specification defines a module system in JavaScript using `import` and `export` syntax, along with a module loader factory (`new Loader`).\n\nA separate browser specification defines the `window.System` loader, a dynamic browser loader for JavaScript modules, as well as a new `<module>` tag (`<script type=\"module\">` for compatibility with existing browsers).\n\nThis polyfill implements the `Loader` and `Module` globals, exactly as specified in the [2013-12-02 ES6 Module Specification Draft](https://github.com/jorendorff/js-loaders/blob/e60d3651/specs/es6-modules-2013-12-02.pdf) and the `System` browser loader exactly as suggested in the [sample implementation](https://github.com/jorendorff/js-loaders/blob/964623c75d/browser-loader.js).\n\nThe complete combined polyfill comes to 16KB minified, making it suitable for production use in future, provided that modules are built into ES5 making them independent of Traceur. Build workflows are currently in progress.\n\n* Provides an asynchronous loader (`System.import`) to [dynamically load ES6 modules](#getting-started) in all modern browsers including IE8+\n* Adds support for the `<script type=\"module\">` tag allowing inline module loading.\n* Uses [Traceur](https://github.com/google/traceur-compiler) for compiling ES6 modules and syntax into ES5 in the browser with source map support\n* Use as a base for creating a [custom spec-compliant module loader](#creating-a-custom-loader)\n* Fully compatible with NodeJS allowing for spec-compliant server-side module loading\n\n_Not yet suitable for production use while the specification is still subject to change._\n\nSee the [demo folder](https://github.com/ModuleLoader/es6-module-loader/blob/master/demo/index.html) in this repo for a working example demonstrating both module loading the module tag.\n\n## Getting Started\n\nDownload both [es6-module-loader.js](https://raw.github.com/ModuleLoader/es6-module-loader/master/dist/es6-module-loader.js) and [traceur.js](https://raw.github.com/ModuleLoader/es6-module-loader/master/lib/traceur.js) into the same folder.\n\nThen include the `es6-module-loader.js` file on its own in the page:\n\n```html\n  <script src=\"es6-module-loader.js\"></script>\n```\n\nTraceur will be downloaded only when needed for ES6 syntax parsing, detected as the existence of module syntax, or as specified by the `metadata.es6 = true` property.\n\nWrite an ES6 module:\n\nmymodule.js:\n```javascript\n  export class q {\n    constructor() {\n      console.log('this is an es6 class!');\n    }\n  }\n```\n\nWe can then load this module with a module tag in the page:\n\n```html\n<script type=\"module\">\n  // loads the 'q' export from 'mymodule.js' in the same path as the page\n  import { q } from 'mymodule';\n\n  new q(); // -> 'this is an es6 class!'\n</script>\n```\n\nOr we can also use the dynamic loader:\n\n```html\n<script>\n  System.import('mymodule').then(function(m) {\n    new m.q();\n  });\n</script>\n```\n\nThe dynamic loader returns an instance of the `Module` class, which contains getters for the named exports (in this case, `q`).\n\nNote that the dynamic module loader uses promises for resolution. Modules can have both a resolve and reject handler:\n\n```javascript\n  System.import('some-module').then(function(m) {\n    // got Module instance m\n  }, function(err) {\n    // error\n  });\n```\n\n## Terminology\n\n### Modules and Module Loaders\n\nA module is simply a JavaScript file written with module syntax. Modules _export_ values, which can then be _imported_ by other modules.\n\n[CommonJS](http://wiki.commonjs.org/wiki/CommonJS) and [AMD](https://github.com/amdjs/amdjs-api/wiki/AMD) JavaScript files are modules.\n\nA module loader provides the ability to dynamically load modules, and also keeps track of all loaded modules in a module registry.\n\nTypically, in production, the module registry would be populated by an initial compiled bundle of modules. Later in the page state, it may become necessary to dynamically\nload a new module. This module can then share dependencies with the initial page bundle without having to reload any dependencies.\n\nThe ES6 Module Specification defines the module syntax for ES6 module files, and also defines a module loader factory class for creating ES6-compatible module loaders.\n\nModule code is treated differently to scripts due to the nature of exports and imports. This is why the `<script type=\"module\">` tag (which will become the `<module>` tag in modern browsers) is introduced to distinguish script code from module code. Scripts cannot export or import, but are able to use the dynamic loader `System.import(...)`.\n\n### Module Names and baseURL\n\nModule names are just like moduleIDs in RequireJS. Non-relative module names (not starting with `.`) are converted to a URL with the following rule:\n\n```javascript\n  URL = absolutePath(baseURL, ModuleName + '.js')\n```\n\nRelative module names can be written `'./local-module'` to load relative to their parent module name. `..` syntax is also supported allowing easily portable modules.\n\nThe `baseURL` is set to the current page path by default. It is a property of the `System` loader and can be changed:\n\n```javascript\n  System.baseURL = '/lib/';\n  System.baseURL = 'http://mysite.com/js/';\n```\n\n## ES6 Module Syntax\n\n### Exporting\n\nES6 module syntax is most similar to the `exports.method = function() {}` pattern in NodeJS of creating multiple named exports.\n\nIn CommonJS one might write:\n\n```javascript\n  exports.someMethod = function() {\n\n  }\n\n  exports.another = {};\n```\n\nIn ES6, this same code would be written:\n\nexporter.js:\n```javascript\n  export function someMethod() {\n\n  }\n\n  export var another = {};\n```\n\nNotice that the name of the function, class or variable gets used as the export name.\n\n### Importing\n\nWhen importing, we import any exports we need by name, and can also choose to rename them:\n\nimporter.js:\n```javascript\n  import { someMethod, another as newName } from './exporter';\n\n  someMethod();\n  typeof newName == 'object';\n```\n\n### Default Import and Export\n\nSometimes one doesn't want to write an import name at all. For this we can use the default export:\n\nexport-default.js:\n```javascript\n  export default function foo() {\n    console.log('foo');\n  }\n```\n\nimport-default.js:\n```javascript\n  import customName from './export-default';\n\n  customName(); // -> 'foo'\n```\n\n### All Supported Syntax\n\nThere are a few other variations of module syntax, the full list of supported statements is listed below.\n\n```javascript\nimport 'jquery';                        // import a module without any import bindings\nimport $ from 'jquery';                 // import the default export of a module\nimport { $ } from 'jquery';             // import a named export of a module\nimport { $ as jQuery } from 'jquery';   // import a named export to a different name\n\nexport var x = 42;                      // export a named variable\nexport function foo() {};               // export a named function\nexport q = {};                          // export shorthand\n\nexport default 42;                      // export the default export\nexport default function foo() {};       // export the default export as a function\n\nexport { encrypt };                     // export an existing variable\nexport { decrypt as dec };              // export a variable as a new name\nexport { encrypt as en } from 'crypto'; // export an export from another module\nexport * from 'crypto';                 // export all exports from another module\n\nmodule crypto from 'crypto';            // import an entire module instance object\n```\n\nNote that any valid declaration can be exported. In ES6, this includes `class` (as in the example above), `const`, and `let`.\n\n## Paths Implementation\n\n_Note: This is a specification under discussion and not at all confirmed. This implementation will likely change._\n\nThe System loader provides paths rules used by the standard `locate` function.\n\nFor example, we might want to load `jquery` from a CDN location. For this we can provide a paths rule:\n\n```javascript\n  System.paths['jquery'] = '//code.jquery.com/jquery-1.10.2.min.js';\n  System.import('jquery').then(function($) {\n    // ...\n  });\n```\n\nAny reference to `jquery` in other modules will also use this same version.\n\nIt is also possible to define wildcard paths rules. The most specific rule will be used:\n\n```javascript\n  System.paths['lodash/*'] = '/js/lodash/*.js'\n  System.import('lodash/map').then(function(map) {\n    // ...\n  });\n```\n\n## Moving to Production\n\nWhen in production, one wouldn't want to load ES6 modules and syntax in the browser. Rather the modules would be built into ES5 and AMD to be loaded.\n\nAlso, suitable bundling would need to be used.\n\nWe are actively working on these workflows.\n\n## Module Tag\n\nThe module tag supports both named and anonymous use.\n\n### Anonymous Module\n\nThis is just like an anonymous &lt;script> tag, allowing code to be run directly:\n\n```html\n  <script type=\"module\">\n    import 'some-import';\n\n    class q {\n\n    }\n\n    new q();\n  </script>\n```\n\n### Named Module\n\nA named module is just like an anonymous module, but defines the module in the registry as well:\n\n```html\n  <script type=\"module\" name=\"my-module\">\n    export var p = 'named-module';\n  </script>\n  <script>\n    // later on -\n    setTimeout(function() {\n      System.import('my-module').then(function(m) {\n        console.log(m.p); // -> named-module\n      });\n    }, 100);\n  </script>\n```\n\n## NodeJS Support\n\nFor use in NodeJS, the `Module`, `Loader` and `System` globals are provided as exports:\n\n```javascript\n  var System = require('es6-module-loader').System;\n  \n  System.import('some-module').then(callback);\n```\n\nTraceur support requires `npm install traceur`, allowing ES6 syntax in NodeJS:\n\n```javascript\n  var System = require('es6-module-loader').System;\n\n  System.import('es6-file').then(function(module) {\n    module.classMethod();\n  });\n```\n\n### Custom Traceur Location\n\nTo set a custom path to the Traceur parser, specify the `data-traceur-src` attribute on the `<script>` tag used to include the module loader.\n\n## Creating a Custom Loader\n\nThe ES6 specification defines a loader through five hooks:\n\n* Normalize: Given the import name, provide the canonical module name.\n* Locate: Given a canonical module name, provide the URL for the resource.\n* Fetch: Given a URL for a resource, fetch its content.\n* Translate: Given module source, make any source modifications.\n* Instantiate: Given module source, determine its dependencies, and execute it.\n\nVariations of these hooks can allow creating many different styles of loader.\n\nEach hook can either return a result directly, or a promise (thenable) for the result.\n\nTo create a new loader, use the `Loader` constructor:\n\n```javascript\nvar MyLoader = new Loader({\n  normalize: function (name, parentName, parentAddress) {\n    return resolvedName;\n  },\n  locate: function (load) {\n    // load.name is normalized name\n    return this.baseURL + '/' + load.name + '.js';\n  },\n  fetch: function (load) {\n    // return a promise. Alternatively, just use the system fetch\n    // promise -return System.fetch(load)\n    var defer = MyPromiseLibrary.createDeferred();\n    myXhr.get(load.address, defer.resolve, defer.reject);\n    return defer.promise;\n  },\n  translate: function (load) {\n    return load.source;\n  },\n  instantiate: function (load) {\n    // use standard es6 linking\n    return System.instantiate(load);\n\n    // provide custom linking\n    // useful for providing AMD and CJS support\n    return {\n      deps: ['some', 'dependencies'],\n      execute: function(depA, depB) {\n        return new Module({\n          some: 'export'\n        });\n      }\n    };\n  }\n});\n```\n\nFor a more in-depth overview of creating with custom loaders, some resources are provided below:\n* The [System Loader implementation](https://github.com/ModuleLoader/es6-module-loader/blob/master/lib/es6-module-loader.js#L804)\n* [ES6 Loader API guide](https://gist.github.com/dherman/7568080)\n* [ES6 Module Specification, latest draft](https://github.com/jorendorff/js-loaders/blob/e60d3651/specs/es6-modules-2013-12-02.pdf)\n* [Yehuda Katz's essay](https://gist.github.com/wycats/51c96e3adcdb3a68cbc3) (outdated)\n\n## Specification Notes\n\nNotes on the exact specification implementation differences are included below.\n\n### Loader Polyfill\n\n* Implemented exactly to the 2013-12-02 Specification Draft -\n  https://github.com/jorendorff/js-loaders/blob/e60d3651/specs/es6-modules-2013-12-02.pdf\n  with the only exceptions as described here\n\n* Abstract functions have been combined where possible, and their associated functions \n  commented\n\n* Declarative Module Support is entirely disabled, and an error will be thrown if \n  the instantiate loader hook returns undefined\n\n* With this assumption, instead of Link, LinkDynamicModules is run directly\n\n* ES6 support is thus provided through the instantiate function of the System loader\n\n* EnsureEvaluated is removed, but may in future implement dynamic execution pending \n  issue - https://github.com/jorendorff/js-loaders/issues/63\n\n* Realm implementation is entirely omitted. As such, Loader.global and Loader.realm\n  accessors will throw errors, as well as Loader.eval\n\n* Loader module table iteration currently not yet implemented\n\n### System Loader Implementation\n\n* Implemented to https://github.com/jorendorff/js-loaders/blob/master/browser-loader.js,\n  except for Instantiate function\n\n* Instantiate function determines if ES6 module syntax is being used, if so parses with \n  Traceur and returns a dynamic InstantiateResult for loading ES6 module syntax in ES5.\n\n* Custom loaders thus can be implemented by using this System.instantiate function as \n  the fallback loading scenario, after other module format detections.\n\n* Traceur is loaded dynamically when module syntax is detected by a regex (with over-\n  classification), either from require('traceur') on the server, or the \n  'data-traceur-src' property on the current script in the browser, or if not set, \n  'traceur.js' in the same URL path as the current script in the browser.\n\n* The `<script type=\"module\">` tag is supported, but the `<module>` tag is not\n\n* The implemented ondemand / paths functionality is provisional and subject to change\n\nTo follow the current the specification changes, see the marked issues https://github.com/ModuleLoader/es6-module-loader/issues?labels=specification&page=1&state=open.\n\n## Projects using us\n\n* [JSPM Loader](https://github.com/jspm/jspm-loader/) is a RequireJS-style loader using our polyfill to load ES6, AMD, CommonJS and global modules \n\n## Contributing\nIn lieu of a formal styleguide, take care to maintain the existing coding style. Add unit tests for any new or changed functionality. Lint and test your code using [grunt](https://github.com/cowboy/grunt).\n\n_Also, please don't edit files in the \"dist\" subdirectory as they are generated via grunt. You'll find source code in the \"lib\" subdirectory!_\n\n## Release History\n* 0.4.0 Update to revised specification exact algorithm\n* 0.3.3 Traceur parser update, detection regex fixes, better error messages\n* 0.3.2 Use Traceur for all parsing, module tag support, syntax updates, test workflow\n* 0.3.1 IE9 Cross Domain fix, module x from y syntax support, data-init callback support, Traceur fixes\n* 0.3.0 Traceur support, better error reporting, source maps support, normalization simplifications\n* 0.2.4 NodeJS support, relative normalization fixes, IE8 support\n\n## License\nCopyright (c) 2012 Luke Hoban, Addy Osmani, Guy Bedford  \nLicensed under the MIT license.\n",
  "readmeFilename": "README.md",
  "_id": "es6-module-loader@0.4.1",
  "dist": {
    "shasum": "4dc96b4706b553e736ef6e0714a38bcf3c3efd58"
  },
  "_from": "es6-module-loader@",
  "_resolved": "https://registry.npmjs.org/es6-module-loader/-/es6-module-loader-0.4.1.tgz"
}
